{{ define "perf" }}
<!DOCTYPE html>
<html>
	{{ template "header" }}
	<body>
		{{ template "topbar" }}
		<h3> Temps pris pour la construction de l'index. </h3>
		<ul>
			<li>Parsing: découpage des documents en tokens</li>
			<li>IDF: multiplication des TFs, par les IDFs</li>
			<li>Indexing: construction de l'arbre des préfixes</li>
			<li>Serialization: écritures des fichiers</li>
		</ul>
		<table width="100%" cellspacing="0">
			<tr style="background:#EFEFEF">
				<th>Corpus</th>
				<th>Parsing</th>
				<th>IDF</th>
				<th>Indexing</th>
				<th>Serialization</th>
				<th>Total</th>
			</tr>
			{{ range . }}
			<tr>
				<td>{{ .Name }}</td>
				<td>{{ .Parsing | duration  }}</td>
				<td>{{ .IDF | duration }}</td>
				<td>{{ .Indexing | duration }}</td>
				<td>{{ .Serialization | duration }}</td>
				<td>{{ .TotalTime | duration }}</td>
			</tr>
			{{ end }}
		</table>
		<p>
		Voici un <a href="http://www.brendangregg.com/flamegraphs.html">flamegraph</a>
		illustrant les performances lors de l'indexage.
		</p>
		<p>
			<object class="p" data="/graphs/torch.svg" type="image/svg+xml" 
				style="margin:auto;width:100%">
			</object>
		</p>
		<p align="justify">
		On peut s'apercevoir que l'une des opérations les plus couteuses est le stemming.
		La librairie que j'utilise (<a href="https://github.com/surgebase/porter2">https://github.com/surgebase/porter2</a>) est une des plus rapide que j'ai pus tester.
		Différentes expérience tels que l'ajout d'un "cache" n'ont pas permis d'améliorer ça.
		</br>
		Il serait possible de "tricher" en abusant du caractère pré-traité de CS276.
		Ainsi pas besoin de séparer les mots en <a href="https://blog.golang.org/strings">rune</a> quand tous les caractère sont en ASCII.
		De même pas besoin de lowercasé les strings qui le sont déjà.
		</br>
		Cependant en raison de l'utilisation de goroutine pour le traitement des fichiers,
		Le vrais point bloquant est l'ajout des documents traité à l'index.
		Il serait intéressant de chercher à effectuer cette opération de manière concurrente.
		</p>


		</br>
		<h3> Tailles des différents parties de l'index. </h3>
		<ul>
			<li>Index: tableau des docID, delta encoded</li>
			<li>Poids: tableau des valeurs de tfidf</li>
			<li>Arbre des préfixes: pointeurs dans les 2 tableaux précédents</li>
			<li>Titre: liste des titres des documents</li>
		</ul>
		<table width="100%" cellspacing="0">
			<tr style="background:#EFEFEF">
				<th>Corpus</th>
				<th>Index</th>
				<th>Poids</th>
				<th>Arbre</th>
				<th>Titre</th>
				<th>Total</th>
				<th>Initial</th>
				<th>Ratio</th>
			</tr>
			{{ range . }}
			<tr>
				<td>{{ .Name }}</td>
				<td>{{ .Index | size }}</td>
				<td>{{ .Weight | size }}</td>
				<td>{{ .Trie | size }}</td>
				<td>{{ .Titles | size }}</td>
				<td>{{ .TotalSize | size }}</td>
				<td>{{ .Initial | size }}</td>
				<td>{{ .Ratio | printf "%.2f" }}</td>
			</tr>
			{{ end }}
		</table>
		<p align="justify">
		L'élément le plus impactant est clairement le tableaux contenant tous les poids.
		C'est pour cela que j'utilse <a href="https://google.github.io/snappy/">snappy</a>.
		Cela a permis de gagner près de 30% pour la taille du tableau, sans impact sensible sur le temps de serialisation.
		</p>
		<p align="justify">
		Il convient néanmoins de noter que mon tableau des poids stockes les valeurs correspondants aux 3 fonctions utilisable pour la recherche vectorielle.
		Dans un cas d'usage réel une seule valeur serait conservé.
		</p>
	</body>
	<style type="text/css">
		td{text-align:center}
	</style>
</html>
{{ end }}
