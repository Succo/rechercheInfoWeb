<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title> RIW </title>
		<style type="text/css">
		body{
			margin:40px auto;
			max-width:800px;
			line-height:1.6;
			font-size:18px;
			padding:0 10px}
		a:link{
			color:#000;
			text-decoration:none}
		a:visited{color:#000}
		td{text-align:center}
		h1,h2,h3{line-height:1.2}
		</style>
	</head>

	<body>
		<div style="background:rgb(10, 174, 194);padding:4px 10px">
			<a href="/">RIW</a> |
			<a href="/stat">stats</a> |
			<a href="/percentile">percentile</a> |
			<a href="/perf">performances</a>
		</div>

		<h3> Temps pris pour la construction de l'index. </h3>
		<ul>
			<li>Parsing: découpage des documents en tokens</li>
			<li>IDF: multiplication des TFs, par les IDFs</li>
			<li>Indexing: construction de l'arbre des préfixes</li>
			<li>Serialization: écritures des fichiers</li>
		</ul>
		<table width="100%" cellspacing="0">
			<tr style="background:#EFEFEF">
				<th>Corpus</th>
				<th>Parsing</th>
				<th>IDF</th>
				<th>Indexing</th>
				<th>Serialization</th>
				<th>Total</th>
			</tr>
			{{ range . }}
			<tr>
				<td>{{ .Name }}</td>
				<td>{{ .Parsing | duration  }}</td>
				<td>{{ .IDF | duration }}</td>
				<td>{{ .Indexing | duration }}</td>
				<td>{{ .Serialization | duration }}</td>
				<td>{{ .TotalTime | duration }}</td>
			</tr>
			{{ end }}
		</table>
		<p>
		Voici un <a href="http://www.brendangregg.com/flamegraphs.html">flamegraph</a>
		illustrant les performances lors de l'indexage.
		</p>
		<p>
			<object class="p" data="/torch.svg" type="image/svg+xml" 
				style="margin:auto;width:100%">
			<img src="/torch.svg" style="margin:auto;width:100%"
				alt="flammegraph of construction time"/>
			</object>
		</p>
		<p align="justify">
		On peut s'apercevoir que l'une des opérations les plus couteuses est le stemming.
		La librairie que j'utilise (<a href="https://github.com/surgebase/porter2">https://github.com/surgebase/porter2</a>) est une des plus rapide que j'ai pus tester.
		Différentes expérience tels que l'ajout d'un "cache" n'ont pas permis d'améliorer ça.
		</br>
		Cependant il serait possible de "tricher" en abusant du caractère pré-traité de CS276.
		Ainsi pas besoin de séparer les mots en <a href="https://blog.golang.org/strings">rune</a> quand tous les caractère sont en ASCII.
		De même pas besoin de lowercasé les strings qui le sont déjà.
		</p>


		</br>
		<h3> Tailles des différents parties de l'index. </h3>
		<ul>
			<li>Index: tableau des docID, delta encoded</li>
			<li>Poids: tableau des valeurs de tfidf</li>
			<li>Arbre des préfixes: pointeurs dans les 2 tableaux précédents</li>
			<li>Titre: liste des titres des documents</li>
		</ul>
		<table width="100%" cellspacing="0">
			<tr style="background:#EFEFEF">
				<th>Corpus</th>
				<th>Index</th>
				<th>Poids</th>
				<th>Arbre</th>
				<th>Titre</th>
				<th>Total</th>
				<th>Initial</th>
				<th>Ratio</th>
			</tr>
			{{ range . }}
			<tr>
				<td>{{ .Name }}</td>
				<td>{{ .Index | size }}</td>
				<td>{{ .RawWeight | size }}</td>
				<td>{{ .Trie | size }}</td>
				<td>{{ .Titles | size }}</td>
				<td>{{ .TotalSize | size }}</td>
				<td>{{ .Initial | size }}</td>
				<td>{{ .Ratio | printf "%.2f" }}</td>
			</tr>
			{{ end }}
		</table>
		<p align="justify">
		L'élément le plus impactant est clairement le tableaux contenant tous les poids.
		C'est pour cela que j'utilse <a href="https://google.github.io/snappy/">snappy</a>.
		Cela a permis de gagner près de 30% pour la taille du tableau, sans impact sensible sur le temps de serialisation.
		</p>
		<p align="justify">
		PS: bien que les poids calculé avec différentes fonction de poids sont tous stocké,
		le tableau ne prend en compte que un d'entre eux, ce qui serait plus proche d'un usage réel.
		Il semblerait cependant que la taille du tableau varie de près de 15% en fonction du poids.
		</p>

	</body>
</html>
